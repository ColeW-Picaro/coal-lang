%{
open CoalLang.Ast

%}

// Declarations
%start start

%token <string> IDENTIFIER
%token <int> INT_LIT
%token <float> FLOAT_LIT
%token <bool> BOOL_LIT
%token <string> STRING_LIT
%token LPAREN RPAREN WHILE FOR UNTIL IN DO END IF THEN ELSE UNLESS EOF
%token NIL STRING INT FLOAT BOOL LET CLASS SUPER THIS RETURN
%token BANG_EQUAL GREATER_EQUAL LESS_EQUAL EQUAL_EQUAL AND OR PLUS_PLUS MINUS_MINUS DOT_DOT BANG GREATER LESS EQUAL
%token COLON COMMA DOT SLASH STAR MINUS PLUS SEMICOLON

%nonassoc IFX
%nonassoc ELSE
%right EQUAL
%left AND
%left OR
%left BANG_EQUAL GREATER_EQUAL LESS_EQUAL EQUAL_EQUAL GREATER LESS
%nonassoc BOOLEXPR
%left MINUS PLUS
%left SLASH STAR
%nonassoc UMINUS
%right PLUS_PLUS MINUS_MINUS
%left BANG

%type <CoalLang.Ast.Prog> start

%%
// Rules

start: Prog { Prog ($1) }

Prog: StmtList EOF { List.rev($1) }

StmtList: { [] }
        | StmtList Stmt { $2 :: $1  }

// Statements and Expressions
Stmt: Def { $1 }
    | Assign SEMICOLON { $1 }
    | WHILE LPAREN BoolExpr RPAREN Stmt { While($3,$5) }
    | UNTIL LPAREN BoolExpr RPAREN Stmt { While(UnOp(OpBoolNegate, $3),$5) }
   // $1  $2     $3  $4         $5    $6   $7    $8   $9        $10      $11       $12  $13    $14
    | FOR LPAREN LET IDENTIFIER COLON Type EQUAL Expr SEMICOLON BoolExpr SEMICOLON Expr RPAREN Stmt {
        Seq [ MakeVardef(Formal ($4, $6), Some $8) ; While($10, Seq [$14 ; Expr $12] )]
      }
    | DO StmtList END { Seq(List.rev($2)) }
    | IF LPAREN BoolExpr RPAREN Stmt %prec IFX { IfThenElse($3,$5, None) }
    | IF LPAREN BoolExpr RPAREN Stmt ELSE Stmt { IfThenElse($3,$5, Some $7) }
    | UNLESS LPAREN BoolExpr RPAREN Stmt { IfThenElse(UnOp(OpBoolNegate, $3),$5, None) }
    | Expr SEMICOLON { Expr $1 }
    | ReturnStmt { $1 }

Def   : LET IDENTIFIER COLON Type SEMICOLON { MakeVardef(Formal($2, $4), None) }
      | LET IDENTIFIER COLON Type EQUAL Expr SEMICOLON { MakeVardef(Formal ($2, $4), Some $6) }      
      | LET IDENTIFIER COLON Type EQUAL Expr Stmt { Seq [MakeVardef(Formal ($2, $4), Some $6) ; $7] }
      | LET IDENTIFIER LPAREN FuncDeclList RPAREN COLON Type Stmt { MakeFuncdef(Formal ($2, $7), $4, $8) }

ParamList: { [] }
         | ExprList { $1 }

ExprList: Expr { [$1] }
        | ExprList COMMA Expr { $3 :: $1 }  

Formal: IDENTIFIER COLON Type { VardefType(Formal ($1, $3), None) }

FuncDeclList: { [] }
        | FormalDeclList { List.rev $1 }

FormalDeclList: Formal { ($1)::[] }
        | FormalDeclList COMMA Formal { $3 :: $1 }


Assign : IDENTIFIER EQUAL Expr { Assign($1,$3) }

ReturnStmt : RETURN Expr SEMICOLON { Return(Some $2) }

Expr: Literal { $1 }
    | IDENTIFIER { MakeVarRef($1) }
    | IDENTIFIER LPAREN ParamList RPAREN { MakeFuncCall($1, $3) }
    | LPAREN Expr RPAREN { $2 }
    | UnOp { $1 }
    | BinOp { $1 }
    | BoolExpr %prec BOOLEXPR { $1 }

Literal :
      INT_LIT {  Int($1) }
    | FLOAT_LIT {  Float($1) }
    | STRING_LIT { String($1) }
    | BOOL_LIT { Bool($1) }

UnOp: BANG BoolExpr { UnOp(OpBoolNegate, $2) }
    | MINUS Expr %prec UMINUS { UnOp(OpValNegate, $2) }
    | PLUS_PLUS IDENTIFIER { UnOp(OpIncr, MakeVarRef($2)) }
    | MINUS_MINUS IDENTIFIER { UnOp(OpDecr, MakeVarRef($2)) }

BinOp:
      Expr PLUS Expr { BinOp($1, OpPlus, $3) }
    | Expr MINUS Expr { BinOp($1, OpMinus, $3) }
    | Expr STAR Expr { BinOp($1, OpMul, $3) }
    | Expr SLASH Expr { BinOp($1, OpDiv, $3) }

BoolExpr:
      Expr BANG_EQUAL Expr { BinOp($1, OpNotEqual, $3) }
    | Expr GREATER_EQUAL Expr { BinOp($1, OpGreaterEqual, $3) }
    | Expr LESS_EQUAL Expr { BinOp($1, OpLessEqual, $3) }
    | Expr EQUAL_EQUAL Expr { BinOp($1, OpEqual, $3) }
    | Expr LESS Expr { BinOp($1, OpLess, $3) }
    | Expr GREATER Expr { BinOp($1, OpGreater, $3) }
    | BoolExpr AND BoolExpr { BinOp($1, OpAnd, $3) }
    | BoolExpr OR BoolExpr { BinOp($1, OpOr, $3) }

Type: STRING { StringType }
    | INT { IntType }
    | FLOAT { FloatType }
    | BOOL { BoolType }
    | NIL { NilType }



